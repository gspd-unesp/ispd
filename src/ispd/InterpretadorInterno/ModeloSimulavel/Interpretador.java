/* Generated By:JavaCC: Do not edit this line. Interpretador.java */
package ispd.InterpretadorInterno.ModeloSimulavel;

import javax.swing.*;
import javax.swing.filechooser.*;
import java.awt.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;
import java.awt.image.*;
import java.net.*;
import javax.imageio.*;
import java.awt.*;
import java.util.HashSet;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;
import java.io.*;
import ispd.RedesDeFilas.*;

class Interpretador implements InterpretadorConstants {

        public boolean verbose;
        private String textoVerbose = "Saida do Verbose:";
        public boolean erroEncontrado = false;
        private String erros = "Erros Encontrados durante o parser do Modelo Simulavel:";
        private RedesDeFilas redeFilas = new RedesDeFilas();
        private String tarefas = "";
        private String char253 = new Character((char)253).toString();
        private String char252 = new Character((char)252).toString();
        private String char254 = new Character((char)254).toString();
        private int idCs;
        private List<String> listaCS = new ArrayList<String>();
        private List<String> listaConecta = new ArrayList<String>();
        private List<Escravos> listaEscravos = new ArrayList<Escravos>();

        public Interpretador(){
        }

        public void printv(String msg){
                textoVerbose = textoVerbose+"\u005cn>"+msg;
        }

        public void addErro(String msg){
                erros = erros+"\u005cn"+msg;
        }

        public void resuladoParser(){
                if(erroEncontrado){
                        MostraSaida saida = new MostraSaida("Found Errors",erros);
                        saida.setVisible(true);
                }
                else{
                        //JOptionPane.showOptionDialog(null,"Modelo simulavel reconhecido com sucesso","Arquivo Reconhecido", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null);
                        if(verbose){ MostraSaida saida = new MostraSaida("Saida do Reconhecimento",textoVerbose); saida.setVisible(true); }
                }
        }

        public void consomeTokens(){
                Token t = getToken(1);
                while( t.kind != CS0 && t.kind != CS1 && t.kind != CS2 && t.kind != CS3 && t.kind != TAREFA && t.kind != CENTROS_DE_SERVICOS && t.kind != CONEXOES && t.kind != FILAS && t.kind != SERVIDORES && t.kind != EOF){
                        getNextToken();
                        t = getToken(1);
                }
        }

        public void resetaObjetosParser(){
                textoVerbose = "";
                erroEncontrado = false;
                String erros = "Foram encontrados os seguintes erros durante o parser:";
                redeFilas = new RedesDeFilas();
                String tarefas = "";
                listaCS = new ArrayList<String>();
                listaConecta = new ArrayList<String>();
                listaEscravos = new ArrayList<Escravos>();
        }

        public void converterEscravos(){
                addErro("Durante convers\u00c3\u00a3o de escravos:");
                for(Escravos temp:listaEscravos){
                        int id = temp.getNumCs();
                        List<String> maquinas = temp.getMaquinas();
                        int maqInt[] = new int[maquinas.size()];
                        int posicao = 0;
                        for(String tempMaq:maquinas){
                                if(!listaCS.contains(tempMaq)){
                                        addErro("Nome de centro de servi\u00c3\u00a7o n\u00c3\u00a3o encontrado: "+tempMaq);
                                        erroEncontrado = true;
                                }
                                maqInt[posicao] = (listaCS.indexOf(tempMaq));
                                posicao++;
                        }
                        redeFilas.setVetorEscravos(maqInt,id);
                }
        }

        public void constroiMatrizRedeFilas(){
                redeFilas.instanciaMatrizVetor( listaConecta.size() );
                for(String temp:listaConecta){
                        String lista[] = temp.split(char254);
                        if(!listaCS.contains(lista[0])){
                                addErro("Nome de centro de servi\u00c3\u00a7o n\u00c3\u00a3o encontrado: "+lista[0]);
                                erroEncontrado = true;
                        }
                        if(!listaCS.contains(lista[1])){
                                addErro("Nome de centro de servi\u00c3\u00a7o n\u00c3\u00a3o encontrado: "+lista[1]);
                                erroEncontrado = true;
                        }
                        redeFilas.inteligaCSs( listaCS.indexOf(lista[0]), listaCS.indexOf(lista[1]) );
                }
        }

        public RedesDeFilas getRedeFilas(){
                return redeFilas;
        }

        public List<String> getNomeId(){
                return listaCS;
        }

        public void converterTarefas(){
                addErro("Durante convers\u00c3\u00a3o de tarefas:");
                String vetor[] = tarefas.split(char252);
                if(Integer.parseInt(vetor[0]) == 1){
                        String vetor2[] = vetor[1].split(char254);
                        int tamanho = vetor2.length;
                        for(int i=0;i<tamanho;i++){
                                String vetor3[] = vetor2[i].split(char253);
                                if(!listaCS.contains(vetor3[0])){
                                        addErro("Nome de centro de servi\u00c3\u00a7o n\u00c3\u00a3o encontrado: "+vetor3[0]);
                                        erroEncontrado = true;
                                }
                                vetor3[0] = String.valueOf(listaCS.indexOf(vetor3[0]));
                                vetor2[i] = vetor3[0]+char253+vetor3[1]+char253+vetor3[2]+char253+vetor3[3]+char253+vetor3[4]+char253+vetor3[5]+char253+vetor3[6]+char253+vetor3[7];
                        }
                        vetor[1] = "";
                        for(int i=0;i<tamanho;i++){
                                vetor[1] = vetor[1] + vetor2[i] + char254;
                        }
                }
                tarefas = vetor[0]+ char252 + vetor[1];
                if(Integer.parseInt(vetor[0]) == 0){
                        String vetor2[] = vetor[1].split(char253);
                        tarefas += char252+vetor2[10];
                }
        }

        public String getTarefas(){
                return tarefas;
        }

        private class Escravos{

                private int numCs;
                private List<String> maquinas = new ArrayList<String>();

                Escravos(int numCs, List<String> maquinas){
                        this.numCs = numCs;
                        this.maquinas = maquinas;
                }

                public int getNumCs(){
                        return numCs;
                }

                public List<String> getMaquinas(){
                        return maquinas;
                }
        }

  final public void Modelo() throws ParseException {
        resetaObjetosParser();
    try {
      jj_consume_token(MODELO);
      label_1:
      while (true) {
        PartesModelo();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TAREFA:
        case CONEXOES:
        case CENTROS_DE_SERVICOS:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
      }
      jj_consume_token(FIM_MODELO);
      jj_consume_token(0);
                        printv("Reconheceu Modelo()");
                        converterEscravos();
                        converterTarefas();
                        constroiMatrizRedeFilas();
                        resuladoParser();
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
                resuladoParser();
    }
  }

  final public void PartesModelo() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TAREFA:
      Tarefa();
                  printv("Reconheceu Tarefa");
      break;
    case CENTROS_DE_SERVICOS:
      Centros();
                  printv("Reconheceu Centros");
      break;
    case CONEXOES:
      Conexao();
                  printv("Reconheceu Conexao");
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Tarefa() throws ParseException {
    try {
      jj_consume_token(TAREFA);
      TipoCarga();
      jj_consume_token(FIM_TAREFA);

    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void TipoCarga() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANDOM:
      jj_consume_token(RANDOM);
                          tarefas = "0"+char252;
      TipoRandom();
      break;
    case MAQUINA:
      jj_consume_token(MAQUINA);
                           tarefas = "1"+char252;
      label_2:
      while (true) {
        TipoMaquina();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case nome:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
      }
      break;
    case TRACE:
      jj_consume_token(TRACE);
                         tarefas = "2"+char252;
      TipoTrace();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void TipoRandom() throws ParseException {
        Integer dist;
        Token t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11;
    t1 = jj_consume_token(inteiro);
    t2 = jj_consume_token(inteiro);
    t3 = jj_consume_token(inteiro);
    t4 = jj_consume_token(flutuante);
    t5 = jj_consume_token(inteiro);
    t6 = jj_consume_token(inteiro);
    t7 = jj_consume_token(inteiro);
    t8 = jj_consume_token(flutuante);
    t9 = jj_consume_token(inteiro);
    t10 = jj_consume_token(inteiro);
    t11 = jj_consume_token(inteiro);
                tarefas = tarefas+t1.image+char253+t2.image+char253+t3.image+char253+t4.image+char253+t5.image+char253+t6.image+char253+t7.image+char253+t8.image+char253+t9.image+char253+t10.image+char253+t11.image;
  }

  final public Integer Distribuicao() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POISSON:
      t = jj_consume_token(POISSON);
                             {if (true) return 1;}
      break;
    case EXPONENCIAL:
      t = jj_consume_token(EXPONENCIAL);
                                 {if (true) return 2;}
      break;
    case TWOSTAGE:
      t = jj_consume_token(TWOSTAGE);
                              {if (true) return 0;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TipoMaquina() throws ParseException {
        Integer dist;
        Token t1,t2,t3,t4,t5,t6;
    t1 = jj_consume_token(nome);
    t2 = jj_consume_token(inteiro);
    t3 = jj_consume_token(flutuante);
    t4 = jj_consume_token(flutuante);
    t5 = jj_consume_token(flutuante);
    t6 = jj_consume_token(flutuante);
                Double minComp = Double.parseDouble(t3.image);
                Double maxComp = Double.parseDouble(t4.image);
                Double minComc = Double.parseDouble(t5.image);
                Double maxComc = Double.parseDouble(t6.image);
                Double mediaComp = (minComp+maxComp)/2;
                Double mediaComc = (minComc+maxComc)/2;
                tarefas = tarefas+t1.image+char253+t2.image+char253+String.valueOf(minComp)+char253+String.valueOf(maxComp)+char253+String.valueOf(mediaComp)+char253+String.valueOf(minComc)+char253+String.valueOf(maxComc)+char253+String.valueOf(mediaComc)+char254;
  }

  final public void TipoTrace() throws ParseException {
        Token t;
    t = jj_consume_token(nome);

  }

  final public void Centros() throws ParseException {
    try {
      jj_consume_token(CENTROS_DE_SERVICOS);
      label_3:
      while (true) {
        CentrosServ();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CS0:
        case CS1:
        case CS2:
        case CS3:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
      }
      jj_consume_token(FIM_CENTROS_DE_SERVICOS);

    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void CentrosServ() throws ParseException {
        Token t1,t2,t3;
        int temp[] = {-1};
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CS0:
        jj_consume_token(CS0);
        t1 = jj_consume_token(nome);
        t2 = jj_consume_token(inteiro);
        t3 = jj_consume_token(inteiro);
                         idCs = redeFilas.adicionaCentroServico(0,Integer.parseInt(t3.image),Integer.parseInt(t2.image),0,temp);
                         if(listaCS.contains(t1.image)){
                                addErro("Nome de centro de servi\u00c3\u00a7o duplicado na linha "+t1.endLine+", coluna "+t1.endColumn);
                                erroEncontrado = true;
                         }
                         listaCS.add(idCs,t1.image);
        Filas();
        Servidores0();

        break;
      case CS1:
        jj_consume_token(CS1);
        t1 = jj_consume_token(nome);
        t2 = jj_consume_token(inteiro);
        t3 = jj_consume_token(inteiro);
        jj_consume_token(nome);
                         idCs = redeFilas.adicionaCentroServico(1,Integer.parseInt(t3.image),Integer.parseInt(t2.image),0,temp);
                         if(listaCS.contains(t1.image)){
                                addErro("Nome de centro de servi\u00c3\u00a7o duplicado na linha "+t1.endLine+", coluna "+t1.endColumn);
                                erroEncontrado = true;
                         }
                         listaCS.add(idCs,t1.image);
        Filas();
        Servidores1();

        break;
      case CS2:
        jj_consume_token(CS2);
        t1 = jj_consume_token(nome);
        t2 = jj_consume_token(inteiro);
        t3 = jj_consume_token(inteiro);
                         idCs = redeFilas.adicionaCentroServico(2,Integer.parseInt(t3.image),Integer.parseInt(t2.image));
                         if(listaCS.contains(t1.image)){
                                addErro("Nome de centro de servi\u00c3\u00a7o duplicado na linha "+t1.endLine+", coluna "+t1.endColumn);
                                erroEncontrado = true;
                         }
                         listaCS.add(idCs,t1.image);
        Filas();
        Servidores();

        break;
      case CS3:
        jj_consume_token(CS3);
        t1 = jj_consume_token(nome);
        t2 = jj_consume_token(inteiro);
        t3 = jj_consume_token(inteiro);
                         idCs = redeFilas.adicionaCentroServico(3,Integer.parseInt(t3.image),Integer.parseInt(t2.image));
                         if(listaCS.contains(t1.image)){
                                addErro("Nome de centro de servi\u00c3\u00a7o duplicado na linha "+t1.endLine+", coluna "+t1.endColumn);
                                erroEncontrado = true;
                         }
                         listaCS.add(idCs,t1.image);
        Filas();
        Servidores();

        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Filas() throws ParseException {
    try {
      jj_consume_token(FILAS);
      label_4:
      while (true) {
        jj_consume_token(nome);
                                  redeFilas.adicionaFila( idCs );
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case nome:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
      }
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Servidores0() throws ParseException {
        Token t1,t2,t3,t4;
        boolean mestre;
    try {
      jj_consume_token(SERVIDORES);
      t1 = jj_consume_token(nome);
      t2 = jj_consume_token(inteiro);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      mestre = Mestre();
                          redeFilas.adicionaServidorProcto(idCs, 0, mestre, Double.parseDouble(t3.image));
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Servidores() throws ParseException {
        Token t1,t2,t3,t4,t5;
    try {
      jj_consume_token(SERVIDORES);
      label_5:
      while (true) {
        t1 = jj_consume_token(nome);
        t2 = jj_consume_token(inteiro);
        t3 = jj_consume_token(flutuante);
        t4 = jj_consume_token(flutuante);
        t5 = jj_consume_token(flutuante);
                          redeFilas.adicionaServidorCom( idCs, Integer.parseInt(t2.image), Double.parseDouble(t3.image), Double.parseDouble(t5.image), Double.parseDouble(t4.image));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case nome:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_5;
        }
      }
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Servidores1() throws ParseException {
        Token t1,t2,t3,t4,t5;
    try {
      jj_consume_token(SERVIDORES);
      t1 = jj_consume_token(nome);
      t2 = jj_consume_token(inteiro);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
                          redeFilas.adicionaServidoresClr( idCs, Integer.parseInt(t2.image), Double.parseDouble(t3.image), Double.parseDouble(t4.image), Double.parseDouble(t5.image), 0.0 );
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public boolean Mestre() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MESTRE:
        jj_consume_token(MESTRE);
        jj_consume_token(nome);
        jj_consume_token(LMAQ);
        NomesEscravos();
                         {if (true) return true;}
        break;
      case ESCRAVO:
        jj_consume_token(ESCRAVO);
                         {if (true) return false;}
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
    throw new Error("Missing return statement in function");
  }

  final public void NomesEscravos() throws ParseException {
        List<String> temp = new ArrayList<String>();
        Token t;
    label_6:
    while (true) {
      t = jj_consume_token(nome);
                   temp.add(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case nome:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_6;
      }
    }
                Escravos esc = new Escravos(idCs,temp);
                listaEscravos.add(esc);
  }

  final public void Conexao() throws ParseException {
    try {
      jj_consume_token(CONEXOES);
      label_7:
      while (true) {
        Conexoes();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case nome:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_7;
        }
      }
      jj_consume_token(FIM_CONEXOES);

    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Conexoes() throws ParseException {
        Token t1,t2;
    try {
      t1 = jj_consume_token(nome);
      t2 = jj_consume_token(nome);
                         listaConecta.add(t1.image+char254+t2.image);
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  /** Generated Token Manager. */
  public InterpretadorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[12];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2022000,0x2022000,0x10000000,0x10900,0x844000,0x3c,0x3c,0x10000000,0x10000000,0x8400,0x10000000,0x10000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public Interpretador(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Interpretador(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new InterpretadorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Interpretador(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new InterpretadorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Interpretador(InterpretadorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(InterpretadorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[37];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 12; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 37; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
