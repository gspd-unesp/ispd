package ispd.InterpretadorInterno.ModeloIconico;/* Generated By:JavaCC: Do not edit this line. Interpretador.java */

import ispd.InterpretadorInterno.ModeloIconico.InterpretadorConstants;
import ispd.InterpretadorInterno.ModeloIconico.ParseException;

import javax.swing.*;
import javax.swing.filechooser.*;
import java.awt.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;
import java.awt.image.*;
import java.net.*;
import javax.imageio.*;
import java.awt.*;
import java.util.HashSet;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;
import java.io.*;

class Interpretador implements InterpretadorConstants {

        public boolean verbose;
        private String textoVerbose = "Saida do Verbose:";
        public boolean erroEncontrado = false;
        private HashSet<DescreveIconePrivado> listaIcones = new HashSet<DescreveIconePrivado>();
        private HashSet<String> listaNomes = new HashSet<String>();
        private HashSet<String> listaEscravos = new HashSet<String>();
        private HashSet<String> listaConexoes = new HashSet<String>();
        private List<String> escravos2 = new ArrayList<String>();
        private String algoritmo = null;
        private String erros = "Erros encontrados durante o parser do Modelo Iconico:";
        private int numIcones = 0;
        private int numArestas = 0;
        private int numVertices = 0;
        private Boolean cargasConfiguradas = new Boolean(false);;
        private Integer cargasTipoConfiguracao = new Integer(-1);
        private String cargasConfiguracao = new String();
        private int numeroConexoes = 0;

        public Interpretador(){
        }

        public void printv(String msg){
                textoVerbose = textoVerbose+"\u005cn>"+msg;
        }

        public void addErro(String msg){
                erros = erros+"\u005cn"+msg;
        }

        public void resuladoParser(){
                if(erroEncontrado){
                        MostraSaida saida = new MostraSaida("Found Errors",erros);
                        saida.setVisible(true);
                }
                else{
                        //JOptionPane.showOptionDialog(null,"Modelo iconico reconhecido com sucesso","Arquivo Reconhecido", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null);
                        if(verbose){ MostraSaida saida = new MostraSaida("Saida do Reconhecimento",textoVerbose); saida.setVisible(true); }
                }
        }

        public void verificaLabels(){
                for(String temp:listaEscravos){
                        if(!listaNomes.contains(temp)){
                                erroEncontrado = true;
                                addErro("\u005c'"+temp+"\u005c' does not exist!");
                        }
                }
                for(String temp:listaConexoes){
                        if(!listaNomes.contains(temp)){
                                erroEncontrado = true;
                                addErro("\u005c'"+temp+"\u005c' does not exist!");
                        }
                }
        }

        public void escreveArquivo(){
                try{
                        File file = new File("modelosimulavel");
                        FileWriter writer = new FileWriter(file);
                        PrintWriter saida = new PrintWriter(writer,true);
                        saida.println("MODELO");
                        saida.println("TAREFA");
                        switch(cargasTipoConfiguracao){
                                case 0:
                                        saida.println("RANDOM "+cargasConfiguracao);
                                        break;
                                case 1:
                                        saida.println("MAQUINA "+cargasConfiguracao);
                                        break;
                                case 2:
                                        saida.println("TRACE "+cargasConfiguracao);
                                        break;
                        }
                        saida.println("FIM_TAREFA");
                        saida.println("CENTROS_DE_SERVICOS");
                        for(DescreveIconePrivado icone:listaIcones){
                                switch(icone.getTipoIcone()){
                                        case 1:
                                                if(icone.getMestre()){
                                                        saida.printf("CS_0 %s 1 1 FILAS fila_%s SERVIDORES serv_%s 0 %f %f ",icone.getNome(),icone.getNome(),icone.getNome(),icone.getPoderComputacional(),icone.getTaxaOcupacao());
                                                        saida.print("MESTRE "+icone.getAlgoritmo()+" LMAQ ");
                                                        List<String> nos = icone.getEscravos();
                                                        for(String no:nos){
                                                                saida.print(""+no+" ");
                                                        }
                                                        saida.println("");
                                                }else{
                                                        saida.printf("CS_0 %s 1 1 FILAS fila_%s SERVIDORES serv_%s 0 %f %f ",icone.getNome(),icone.getNome(),icone.getNome(),icone.getPoderComputacional(),icone.getTaxaOcupacao());
                                                        saida.print("ESCRAVO");
                                                        saida.println("");
                                                }
                                                break;
                                        case 2: saida.printf("CS_2 %s 1 1 FILAS fila_%s SERVIDORES serv_%s 1 %f %f %f\u005cn",icone.getNome(),icone.getNome(),icone.getNome(),icone.getBanda(),icone.getTaxaOcupacao(),icone.getLatencia());
                                                break;
                                        case 4: saida.printf("CS_3 %s 1 1 FILAS fila_%s SERVIDORES serv_%s 1 %f %f %f\u005cn",icone.getNome(),icone.getNome(),icone.getNome(),icone.getBanda(),icone.getTaxaOcupacao(),icone.getLatencia());
                                                break;
                                        case 3: saida.print("CS_1 "+icone.getNome()+" 2 "+icone.getNumeroEscravos()+" "+icone.getAlgoritmo()+" FILAS fila_0_"+icone.getNome()+" fila_1_"+icone.getNome()+" SERVIDORES ");
                                                        saida.printf("serv_%s 0 %f %f %f ",icone.getNome(),icone.getPoderComputacional(),icone.getBanda(),icone.getLatencia());
                                                        saida.println("");
                                                break;
                                }
                        }
                        saida.println("FIM_CENTROS_DE_SERVICOS");
                        if(numeroConexoes > 0){
                                saida.println("CONEXOES");
                                for(DescreveIconePrivado icone:listaIcones){
                                        if(icone.getTipoIcone()==2){
                                                saida.printf("%s\u005ct%s\u005cn",icone.getSNoOrigem(),icone.getNome());
                                                saida.printf("%s\u005ct%s\u005cn",icone.getNome(),icone.getSNoDestino());
                                        }
                                }
                                saida.println("FIM_CONEXOES");
                        }
                        saida.println("FIM_MODELO");
                        saida.close();
                        writer.close();
                        //JOptionPane.showMessageDialog(null,"File successfully saved\n","Completed",JOptionPane.INFORMATION_MESSAGE);
                }
                // em caso de erro apresenta mensagem abaixo  
                catch(Exception e){
                        JOptionPane.showMessageDialog(null,e.getMessage(),"Warning",JOptionPane.WARNING_MESSAGE);
                }


        }

        public void consomeTokens(){
                Token t = getToken(1);
                while( t.kind != MAQ && t.kind != REDE && t.kind != INET && t.kind != CLUSTER && t.kind != CARGA && t.kind != EOF){
                        getNextToken();
                        t = getToken(1);
                }
        }

        public void resetaObjetosParser(){
                textoVerbose = "";
                erroEncontrado = false;
                listaIcones.clear();
                numIcones = 0;
                numVertices = 0;
                numArestas = 0;
                listaNomes.clear();
                listaEscravos.clear();
                listaConexoes.clear();
                escravos2.clear();
                String algoritmo = null;
                String erros = "Foram encontrados os seguintes erros durante o parser:";
                cargasConfiguradas = new Boolean(false);;
                cargasTipoConfiguracao = new Integer(-1);
                cargasConfiguracao = new String();
                numeroConexoes = 0;
        }

        private class DescreveIconePrivado {

                        private int tipoIcone;
                        private int IdGlobal;
                        private int IdLocal;
                        private String nome;
                        private int x,y,prex,prey;
                        private double poderComputacional;
                        private double taxaOcupacao;
                        private double latencia;
                        private double banda;
                        private int numeroEscravos;
                        private boolean mestre;
                        private String algoritmoEscalonamento;
                        private List<String> escravos;
                        private List<Integer> escravos2;
                        private int noOrigem;
                        private int noDestino;
                        private String snoOrigem;
                        private String snoDestino;
                        private HashSet<Integer> conexaoEntrada;
                        private HashSet<Integer> conexaoSaida;

                        public DescreveIconePrivado(){
                                conexaoEntrada = new HashSet<Integer>();
                                conexaoSaida = new HashSet<Integer>();
                        }
                        public void setAtributosNo(int tipoIcone,int IdLocal,int IdGlobal,String nome,double poderComputacional,double taxaOcupacao,boolean mestre,String algoritmoEscalonamento,List<String> escravos){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = poderComputacional;
                                this.taxaOcupacao = taxaOcupacao;
                                this.latencia = 0.0;
                                this.banda = 0.0;
                                this.mestre = mestre;
                                this.escravos = escravos;
                                this.algoritmoEscalonamento = algoritmoEscalonamento;
                                this.numeroEscravos = 0;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = null;
                                this.snoDestino = null;
                        }
                        public void setAtributosLink(int tipoIcone,int IdLocal,int IdGlobal,String nome,double taxaOcupacao,double latencia,double banda,String snoOrigem, String snoDestino){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = 0.0;
                                this.taxaOcupacao = taxaOcupacao;
                                this.latencia = latencia;
                                this.banda = banda;
                                this.mestre = false;
                                this.escravos = new ArrayList<String>();
                                this.algoritmoEscalonamento = null;
                                this.numeroEscravos = 0;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = snoOrigem;
                                this.snoDestino = snoDestino;
                        }
                        public void setAtributosCluster(int tipoIcone,int IdLocal,int IdGlobal,String nome,double poderComputacional,double latencia,double banda, String algoritmoEscalonamento, int numeroEscravos){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = poderComputacional;
                                this.taxaOcupacao = 0.0;
                                this.latencia = latencia;
                                this.banda = banda;
                                this.mestre = false;
                                this.escravos = new ArrayList<String>();
                                this.algoritmoEscalonamento = algoritmoEscalonamento;
                                this.numeroEscravos = numeroEscravos;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = null;
                                this.snoDestino = null;
                        }
                        public void setAtributosInet(int tipoIcone,int IdLocal,int IdGlobal,String nome,double taxaOcupacao,double latencia,double banda){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = 0.0;
                                this.taxaOcupacao = taxaOcupacao;
                                this.latencia = latencia;
                                this.banda = banda;
                                this.mestre = false;
                                this.escravos = new ArrayList<String>();
                                this.algoritmoEscalonamento = null;
                                this.numeroEscravos = 0;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = null;
                                this.snoDestino = null;
                        }
                        public void addConexaoEntrada(int num){conexaoEntrada.add(num);}
                        public void addConexaoSaida(int num){conexaoSaida.add(num);}
                        public void addEscravos2(int id){escravos2.add(id);}
                        public int getTipoIcone(){return  tipoIcone;}
                        public int getIdGlobal(){return  IdGlobal;}
                        public int getIdLocal(){return  IdLocal;}
                        public String getNome(){return  nome;}
                        public int getNumX(){return  x;}
                        public int getNumY(){return  y;}
                        public void setX(int x){this.x = x;}
                        public void setY(int y){this.y = y;}
                        public int getNumPreX(){return  prex;}
                        public int getNumPreY(){return  prey;}
                        public void setPreX(int x){this.prex = x;}
                        public void setPreY(int y){this.prey = y;}
                        public double getPoderComputacional(){return  poderComputacional;}
                        public double getTaxaOcupacao(){return  taxaOcupacao;}
                        public double getLatencia(){return  latencia;}
                        public double getBanda(){return  banda;}
                        public boolean getMestre(){return  mestre;}
                        public List<String> getEscravos(){return  escravos;}
                        public List<Integer> getEscravos2(){return  escravos2;}
                        public String getAlgoritmo(){return  algoritmoEscalonamento;}
                        public int getNumeroEscravos(){return numeroEscravos;}
                        public void setNoOrigem(int no){this.noOrigem = no;}
                        public void setNoDestino(int no){this.noDestino = no;}
                        public int getNoOrigem(){return noOrigem;}
                        public int getNoDestino(){return noDestino;}
                        public String getSNoOrigem(){return snoOrigem;}
                        public String getSNoDestino(){return snoDestino;}
                        public HashSet<Integer> getConexaoEntrada(){return conexaoEntrada;}
                        public HashSet<Integer> getConexaoSaida(){return conexaoSaida;}
        }

  final public void Modelo() throws ParseException {
        resetaObjetosParser();
    try {
      Icones();
      jj_consume_token(0);
                        printv("Reconheceu Modelo()");

                        verificaLabels();

                        resuladoParser();
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
                resuladoParser();
    }
  }

  final public void Icones() throws ParseException {
    label_1:
    while (true) {
      Icone();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAQ:
      case REDE:
      case INET:
      case CARGA:
      case CLUSTER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
                  printv("Reconheceu Icones");
  }

  final public void Icone() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAQ:
      No();
                  printv("Reconheceu No()");
      break;
    case CLUSTER:
      Cluster();
                  printv("Reconheceu Cluster()");
      break;
    case REDE:
      Link();
                  printv("Reconheceu Link()");
      break;
    case INET:
      Inet();
                  printv("Reconheceu Inet()");
      break;
    case CARGA:
      Carga();
                  printv("Reconheceu Carga()");
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public boolean NoTipo() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MESTRE:
      jj_consume_token(MESTRE);
      algoritmo = ClusterAlg();
      jj_consume_token(LMAQ);
      NoLista();
                                                           {if (true) return true;}
      break;
    case ESCRAVO:
      jj_consume_token(ESCRAVO);
                      {if (true) return false;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void NoLista() throws ParseException {
        Token t;
        String s;
        escravos2.clear();
    label_2:
    while (true) {
      t = jj_consume_token(nome);
                  s = t.image; escravos2.add(s); listaEscravos.add(s); printv("Reconheceu nome no escravo");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case nome:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
    }
  }

  final public void No() throws ParseException {
        Boolean mestre;
        Token t2, t3, t4;
        DescreveIconePrivado icone = new DescreveIconePrivado();
        List<String> escravos = new ArrayList<String>();
    try {
      jj_consume_token(MAQ);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      mestre = NoTipo();
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }

                        if(mestre){icone.setAtributosNo(1, numVertices, numIcones, t2.image, Double.parseDouble(t3.image), Double.parseDouble(t4.image), true, algoritmo, escravos2);
                                        listaIcones.add(icone);
                                        numIcones++;
                                        numVertices++;
                                        algoritmo = null;
                                }
                        else{icone.setAtributosNo(1, numVertices, numIcones, t2.image, Double.parseDouble(t3.image), Double.parseDouble(t4.image), false, algoritmo, escravos);
                                        listaIcones.add(icone);
                                        numIcones++;
                                        numVertices++;
                                }
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Link() throws ParseException {
        Token t2, t3, t4, t5, t6, t7;
        DescreveIconePrivado icone = new DescreveIconePrivado();
    try {
      jj_consume_token(REDE);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
      jj_consume_token(CONECTA);
      t6 = jj_consume_token(nome);
      t7 = jj_consume_token(nome);
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }

                        if(!listaConexoes.contains(t6.image)){ listaConexoes.add(t6.image); }
                        if(!listaConexoes.contains(t7.image)){ listaConexoes.add(t7.image); }
                        icone.setAtributosLink(2, numArestas, numIcones , t2.image, Double.parseDouble(t5.image), Double.parseDouble(t4.image), Double.parseDouble(t3.image), t6.image, t7.image);
                        listaIcones.add(icone);
                        numArestas++;
                        numIcones++;
                        numeroConexoes++;
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public String ClusterAlg() throws ParseException {
        Token t;
        String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RR:
      t = jj_consume_token(RR);
                 s = t.image; {if (true) return s;}
      break;
    case WORKQUEUE:
      t = jj_consume_token(WORKQUEUE);
                          s = t.image; {if (true) return s;}
      break;
    case FPLTF:
      t = jj_consume_token(FPLTF);
                      s = t.image; {if (true) return s;}
      break;
    case VAZIO:
      t = jj_consume_token(VAZIO);
                      s = t.image; {if (true) return s;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Cluster() throws ParseException {
        String s;
        Token t2, t3, t4, t5, t6, t7;
        DescreveIconePrivado icone = new DescreveIconePrivado();
    try {
      jj_consume_token(CLUSTER);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(inteiro);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
      t6 = jj_consume_token(flutuante);
      s = ClusterAlg();
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }
                        icone.setAtributosCluster(3, numVertices, numIcones, t2.image, Double.parseDouble(t4.image), Double.parseDouble(t6.image), Double.parseDouble(t5.image), s,  Integer.parseInt(t3.image));
                        listaIcones.add(icone);
                        numIcones++;
                        numVertices++;
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Inet() throws ParseException {
        Token t2, t3, t4, t5, t6, t7;
        DescreveIconePrivado icone = new DescreveIconePrivado();
        //escravos.clear();
        HashSet<String> nosConectados = new HashSet<String>();
        List<String> escravos = new ArrayList<String>();
    try {
      jj_consume_token(INET);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }
                        icone.setAtributosInet(4, numVertices,numIcones, t2.image, Double.parseDouble(t5.image), Double.parseDouble(t4.image), Double.parseDouble(t3.image));
                        listaIcones.add(icone);
                        numIcones++;
                        numVertices++;
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Carga() throws ParseException {
        cargasConfiguradas = true;
    try {
      jj_consume_token(CARGA);
      TipoCarga();
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void TipoCarga() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANDOM:
      jj_consume_token(RANDOM);
      TipoRandom();
      break;
    case MAQUINA:
      jj_consume_token(MAQUINA);
      label_3:
      while (true) {
        TipoMaquina();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case nome:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
      }
      break;
    case TRACE:
      jj_consume_token(TRACE);
      TipoTrace();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void TipoRandom() throws ParseException {
        String dist;
        Token t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11;
        cargasTipoConfiguracao = 0;
    t1 = jj_consume_token(inteiro);
    t2 = jj_consume_token(inteiro);
    t3 = jj_consume_token(inteiro);
    t4 = jj_consume_token(flutuante);
    t5 = jj_consume_token(inteiro);
    t6 = jj_consume_token(inteiro);
    t7 = jj_consume_token(inteiro);
    t8 = jj_consume_token(flutuante);
    t9 = jj_consume_token(inteiro);
    t10 = jj_consume_token(inteiro);
    t11 = jj_consume_token(inteiro);
                cargasConfiguracao = t1.image+" "+t2.image+" "+t3.image+" "+t4.image+"\u005cn"+t5.image+" "+t6.image+" "+t7.image+" "+t8.image+"\u005cn"+t9.image+" "+t10.image+" "+t11.image;
  }

  final public String Distribuicao() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POISSON:
      t = jj_consume_token(POISSON);
                             {if (true) return t.image;}
      break;
    case EXPONENCIAL:
      t = jj_consume_token(EXPONENCIAL);
                                 {if (true) return t.image;}
      break;
    case TWOSTAGE:
      t = jj_consume_token(TWOSTAGE);
                              {if (true) return t.image;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TipoMaquina() throws ParseException {
        String dist;
        Token t1,t2,t3,t4,t5,t6;
        cargasTipoConfiguracao = 1;
    t1 = jj_consume_token(nome);
    t2 = jj_consume_token(inteiro);
    t3 = jj_consume_token(flutuante);
    t4 = jj_consume_token(flutuante);
    t5 = jj_consume_token(flutuante);
    t6 = jj_consume_token(flutuante);
                cargasConfiguracao += ""+t1.image+" "+t2.image+" "+t3.image+" "+t4.image+" "+t5.image+" "+t6.image+"\u005cn";
  }

  final public void TipoTrace() throws ParseException {
        Token t;
        cargasTipoConfiguracao = 2;
    t = jj_consume_token(nome);
                cargasConfiguracao = t.image+"\u005cn";
  }

  /** Generated Token Manager. */
  public InterpretadorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[8];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x4164,0x4164,0x2400,0x200000,0x4008a,0x200000,0x10a00,0xa1000,};
   }

  /** Constructor with InputStream. */
  public Interpretador(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Interpretador(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new InterpretadorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Interpretador(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new InterpretadorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Interpretador(InterpretadorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(InterpretadorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[30];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 8; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 30; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
